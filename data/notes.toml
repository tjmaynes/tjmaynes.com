[[notes]]
content = 'Make each program do one thing well. To do a new job, build afresh rather than complicate old programs by adding new "features".'
source_link = "https://en.wikipedia.org/wiki/Unix_philosophy"
tags = ["unix philosophy", "software design"]

[[notes]]
content = "Expect the output of every program to become the input to another, as yet unknown, program. Don't clutter output with extraneous information. Avoid stringently columnar or binary input formats. Don't insist on interactive input."
source_link = "https://en.wikipedia.org/wiki/Unix_philosophy"
tags = ["unix philosophy", "software design"]

[[notes]]
content = "Design and build software, even operating systems, to be tried early, ideally within weeks. Don't hesitate to throw away the clumsy parts and rebuild them."
source_link = "https://en.wikipedia.org/wiki/Unix_philosophy"
tags = ["unix philosophy", "software design"]

[[notes]]
content = "Use tools in preference to unskilled help to lighten a programming task, even if you have to detour to build the tools and expect to throw some of them out after you've finished using them."
source_link = "https://en.wikipedia.org/wiki/Unix_philosophy"
tags = ["unix philosophy", "software design"]

[[notes]]
content = "Tests are Rust functions that verify that the non-test code is functioning in the expected manner."
source_link = "https://doc.rust-lang.org/book/ch11-01-writing-tests.html#how-to-write-tests"
code_content = """
```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
```
"""
tags = ["rust"]

[[notes]]
content = "Result<T, E> is the type used for returning and propagating errors. It is an enum with the variants, Ok(T), representing success and containing a value, and Err(E), representing error and containing an error value. Functions return Result whenever errors are expected and recoverable. In the std crate, Result is most prominently used for I/O."
source_link = "https://doc.rust-lang.org/std/result/"
code_content = """
```rust
enum Result<T, E> {
  Ok(T),
  Err(E),
}
```
"""
tags = ["rust", "functional_programming"]

[[notes]]
content = "A monad is an abstract data type that allows programmers to chain complex, nondeterministic operations."
source_link = "https://en.wikipedia.org/wiki/Monad_(functional_programming)"
tags = ["functional programming"]

[[notes]]
content = "An abstract data type (ADT) is a kind of data type defined by it's behavior from the point of view from a user. Since an ADT is created from the user's point of view, it's internal presentation is hidden, thus enabling us to focus more on behavior than caring what data is being held (it could be a String, Integer, YourCustomObject, etc)."
tags = ["functional programming", "software design"]

[[notes]]
content = "A protagonist and his/her story can be only as intellectually fascinating and emotionally compelling as the forces of antagonism make them. - Robert McKee (Story)"
tags = ["storytelling"]

[[notes]]
content = "It is only by competing for the same goal that the hero and the opponent are forced into direct conflict and to do so again and again throughout the story. - John Truby (Anatomy of Story)"
tags = ["storytelling"]

[[notes]]
content = "All sound is made of vibrations traveling through air. Synthesizers control vibrations. A cycle is a unit of vibration. Frequency is the speed of vibration measured in Hertz, or cycles per second. All sound is made up of three elements: Pitch timbre, and volume."
tags = ["music"]

[[notes]]
content = "A digital camera uses an array of millions of tiny light cavities or \"photosites\" to record an image. When you press your camera's shutter button and the exposure begins, each of these is uncovered to collect photons and store those as an electrical signal. Once the exposure finishes, the camera closes each of these photosites, and then tries to assess how many photons fell into each cavity by measuring the strength of the electrical signal. The signals are then quantified as digital values, with a precision that is determined by the bit depth. The resulting precision may then be reduced again depending on which file format is being recorded (0 - 255 for an 8-bit JPEG file)."
tags = ["filmmaking"]

[[notes]]
content = "Your personal situation, including your risk tolerance, risk capacity, time frame, and financial needs, will drive nearly all of your investment decisions."
tags = ["finances"]

[[notes]]
content = "Instead of trying to remember everything you did with your brain, maintain a \"brag document\" that lists everything so you can refer to it when you get to performance review season."
source_link = "https://jvns.ca/blog/brag-documents/"
tags = ["career"]

[[notes]]
content = "Under the \"laissez-faire\" agreement, employees are encourages to think of themselves as \"free agents\", looking to other companies for opportunities for growth and changing jobs whenever better ones beckon. The new \"compact\" acknowledges the probable importance of the relationship yet seeks to build trust and investment anyway. As allies, employer and employee try to add value to each other. \"If you help me grown and flourish, I will help the company grow and flourish.\""
source_link = "https://hbr.org/2013/06/tours-of-duty-the-new-employer-employee-compact"
tags = ["career"]

[[notes]]
content = "An IAM user doesn't have to represent an actual person; you can create an IAM user in order to generate an access key for an application that runs in your corporate network and needs AWS access. By default, users can't access anything in your account. You grant permissions to a user by creating a policy, which is a document that defines the effect, actions, resources, and optional conditions."
source_link = "https://aws.amazon.com/documentation/iam"
tags = ["aws"]

[[notes]]
content = "Remember: Chaos Engineering is focused on controlled failure-injection. The purpose of these experiments is to simulate disaster conditions. Focus on availability in the beginning, or lack thereof."
source_link = "https://principlesofchaos.org"
tags = ["automation", "availability"]

[[notes]]
content = "Different types of databases and their respective uses."
code_content = """
```markdown
| Purpose-Built For  | Optimized for When you need to                         | Example Workload   |
| :----------------: | :----------------------------------------------------: | :----------------: |
| Row Store          | Operate on a record or group of records                | Payroll            |
| Column Store       | Aggregations, scans and joins                          | Analytics          |
| Key-Value Store    | Query by Key with high throughput and fast aggregation | Tracking Devices   |
| Document Store     | Index and Store documents for query on any property    | Patient Data       |
| Graph Store        | Persist and retrieve relationships                     | Recommendations    |
| Time-Series Store  | Store and process data sequence                        | Monitoring         |
| Unstructured Store | Get and Put of Objects                                 | Store user reviews |
```
"""
tags = ["databases"]

[[notes]]
content = "Try to avoid using ORM libraries (use query-builders instead) becauses the syntax for one ORM is going to be different to another ORM, ORMs will do extra work than necessary due to the abstraction being too general, and ORMs make it difficult to build complex queries."
source_link = "https://blog.logrocket.com/why-you-should-avoid-orms-with-examples-in-node-js-e0baab73fa5/"
tags = ["software design"]

[[notes]]
content = "Collaborative filtering is a method of making automatic predictions (filtering) about the interests of a user by collecting preferences or taste information from many users (collaborating). If a person A has the same opinion as a person B on an issue, A is more likely to have B's opinion on a different issue than that of a randomly chosen person. \"People often get the best recommendations from someone with tastes similar to themselves.\" - thus being able to make recommendations for these people."
source_link = "https://en.wikipedia.org/wiki/Collaborative_filtering"
tags = ["automation", "machine learning"]

[[notes]]
content = "A pod is the smallest deployable units of computing that can be created and managed in Kubernetes."
source_link = "https://kubernetes.io/docs/concepts/workloads/pods/"
tags = ["kubernetes"]

[[notes]]
content = "Istio is a suite of tools for controlling the flow of traffic and API calls between services, conduct a range of tests, and upgrade gradually with red/black deployments."
source_link = "https://istio.io/latest/about/service-mesh/"
tags = ["kubernetes", "service-mesh"]

[[notes]]
content = "A service mesh is a network of microservices that make up applications and interactions between them. As a service mesh grows in size and complexity, it becomes harder to understand and manage. Requirements include discovery, load balancing, failure recovery, metrics, and monitoring. Also, includes A/B testing, canary rollouts, rate limiting, access control, and end-to-end authentication."
source_link = "https://istio.io/latest/about/service-mesh/"
tags = ["kubernetes", "service-mesh"]

[[notes]]
content = "Istio offers automated load balancing for HTTP, gRPC, WebSocket, and TCP traffic. Fine-grained control of traffic behavior with rich routing rules, retries, failover, and fault injection. A pluggable policy layer and configuration API supporting access controls, rate limits, and quotas. Automatic metics, logs, and traces for all traffic within a cluster, including cluster ingress and egress. Secure service-to-service communication in a cluster with strong identity-based AuthN and AuthZ."
source_link = "https://istio.io/latest/about/service-mesh/"
tags = ["kubernetes", "service-mesh"]

[[notes]]
content = "Kubernetes assigns each Pod an IP address, and a single DNS name for each set of Pods, and can load-balance across each set of Pods."
source_link = "https://kubernetes.io/docs/concepts/services-networking/service/"
tags = ["kubernetes", "service-mesh"]

[[notes]]
content = "Seroter's Theory - You can't avoid lock-in everywhere. Portability versus vendor lock-in is a business decision, not a technical one."
source_link = "https://www.slideshare.net/Pivotal/debunking-myths-about-cloud-portability-101013216"
tags = ["cloud-native"]

[[notes]]
content = "Berkholz's Accordion - IT is like an accordion and at any moment, there are parts of it that are expanding and parts of it that are contracting."
source_link = "https://medium.com/built-to-adapt/diversify-your-cloud-portfolio-or-bank-on-failure-dabaead526a1"
tags = ["cloud-native"]

[[notes]]
content = "Mckenty's ratio - How much choice do people really need? 5:2. No more than 5 categories. No more than 2 options per category."
source_link = "https://www.slideshare.net/Pivotal/debunking-myths-about-cloud-portability-101013216"
tags = ["cloud-native"]

[[notes]]
content = "The microservice architectural style is an approach to developing a single application as a suite a small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API."
source_link = "https://martinfowler.com/articles/microservices.html"
tags = ["microservices"]

[[notes]]
content = "Chaos Engineering can be thought of as the facilitation of experiments to uncover systemic weaknesses. These experiments follow four steps: 1). Start by defining 'steady state' as some measurable output of a system that indicates normal behavior. (Baseline). 2). Hypothesize that this steady state will continue in both the control group and the experimental group. (Test groups). 3). Introduce variables that reflect real world events like servers that crash, hard drives that malfunction, network connections that severed. 4). Try to disprove the hypothesis by looking for a difference in steady state between the control group and the experimental group."
source_link = "https://principlesofchaos.org"
tags = ["automation", "availability"]

[[notes]]
content = "To implement agile software development, teams plan, design, test, build, accept and deploy changes to their customers through iterations, rapidly. The culture promotes transparency (through standups, retrospectives, etc), flexibility (items in backlog are prioritized when requirements change), predictability (work is prioritized and time-boxed to sprints lasting 1-2 week cycles), and focusing on business value (\"what value are we working on for the customer?\")."
source_link = "https://tanzu.vmware.com/agile"
tags = ["agile software development", "consulting"]

[[notes]]
content = "According to Pivotal Labs, agile software development is a set of methods that result in fast and frequent delivery of value to customers. It promotes well-planned, small iterations by highly collaborative cross-functional teams. However, to accomplish this \"business must be culturally ready for the change and committed to coaching/training.\""
source_link = "https://tanzu.vmware.com/agile"
tags = ["agile software development", "consulting"]

[[notes]]
content = "Value is derived from the business and users, each feature delivers incremental value and quality is improved as a result of being able to locate and fix issues more easily and rapidly through test-driven development."
source_link = "https://tanzu.vmware.com/agile"
tags = ["agile software development", "consulting"]

[[notes]]
content = "Simply asking \"why\" in the beginning of the engagement can have a positive effect on the team, helping them to become aware of the blind spots that may have developed as a result of pickling."
tags = ["agile software development", "consulting"]

[[notes]]
content = "A small system that tries to change a big system through long and continued contact is more likely to be changed itself. The challenge is how to get the client in long, continued contact with some kind of brine, without the consultant even being present."
source_link = "https://blog.testdouble.com/posts/2019-04-29-weinberg-pickle-principle/"
tags = ["agile software development", "consulting"]

[[notes]]
content = "To continuously deliver app updates to your users, you need an automated process that reliably builds, tests, and updates your software. Code changes should automatically flow through a pipeline that includes artifact creation, unit/integration testing, functional testing, and production rollout."
tags = ["agile software development"]

[[notes]]
content = "Accelerating the time between commit and deploy allows developers to diagnose and react to issues while the change is fresh in their minds."
tags = ["agile software development"]

[[notes]]
content = "A more frequent release Cadence helps reduce issues such as incompatible upstream dependencies."
tags = ["agile software development"]

[[notes]]
content = "An end-to-end test both the system and the process by which it's built and deployed. An end-to-end test interacts with the system only from the outside: through its user interface, by sending messages as if from a third-party system, by invoking its web services, by parsing reports, and so on."
tags = ["software testing"]

[[notes]]
content = "UI/Acceptance tests prove a feature works as expected for the end user. Tests that check the functionality we want to build. Does the whole system work?"
tags = ["software testing"]

[[notes]]
content = "Integration tests that many units work together as a whole. Does our code work against code that we can't change? Tests that check how some of our code works with code from outside the team that we can't change."
tags = ["software testing"]

[[notes]]
content = "A load test is a planned test to perform a specific number of requests to a system in order to test the functionality of the system under specific levels of simultaneous requests."
tags = ["software testing"]

[[notes]]
content = "An endurance test is used to test a system with extreme load extended over a significant period of time, to discover how the system behaves under sustained use. Goals include checking for memory leaks, connection issues between systems, database connection closed successfully."
source_link = "https://www.guru99.com/endurance-testing.html"
tags = ["software testing"]

# - "Thank You" (Flat hand from chin and extend out)
# - "I can't hear you" (Three finger shake)
# - "Same" (Hangloose and extend out)
# - "Finish" (hands under 'tray' drop to floor)
# - "Full" (Flat hand under chin)